 [B107 (ENTRY)]
   Succs (1): B106

 [B1]
   1: return n;
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: _PyNode_FinalizeEndPos(n)
   Preds (1): B3
   Succs (1): B1

 [B3]
  done:
   1: PyTokenizer_Free(tok)
   2: n != ((void *)0)
   T: if [B3.2]
   Preds (6): B4 B5 B12 B13 B16 B20
   Succs (2): B2 B1

 [B4]
   1: strcpy(r->n_str, tok->encoding)
   2: PyMem_Free(tok->encoding)
   3: tok->encoding = ((void *)0)
   4: r->n_nchildren = 1
   5: r->n_child = n
   6: n = r
   Preds (1): B8
   Succs (1): B3

 [B5]
   1: n = ((void *)0)
   T: goto done;
   Preds (2): B6 B7
   Succs (1): B3

 [B6]
   1: PyObject_Free(r)
   Preds (1): B7
   Succs (1): B5

 [B7]
   1: err_ret->error = 15
   2: r (ImplicitCastExpr, LValueToRValue, node *)
   T: if [B7.2]
   Preds (2): B8 B9
   Succs (2): B6 B5

 [B8]
   1: !r->n_str
   T: if [B9.1] || [B8.1]
   Preds (1): B9
   Succs (2): B7 B4

 [B9]
   1: !r
   T: [B9.1] || ...
   Preds (2): B10 B11
   Succs (2): B7 B8

 [B10]
   1: strlen(tok->encoding)
   2: PyObject_Malloc([B10.1] + 1)
   3: r->n_str = [B10.2]
   Preds (1): B11
   Succs (1): B9

 [B11]
   1: PyNode_New(341)
   2: node *r = PyNode_New(341);
   3: r (ImplicitCastExpr, LValueToRValue, node *)
   T: if [B11.3]
   Preds (1): B12
   Succs (2): B10 B9

 [B12]
   1: tok->encoding != ((void *)0)
   T: if [B12.1]
   Preds (1): B23
   Succs (2): B11 B3

 [B13]
   1: err_ret->text[len] = '\x00'
   Preds (2): B14 B15
   Succs (1): B3

 [B14]
   1: strncpy(err_ret->text, tok->buf, len)
   Preds (1): B15
   Succs (1): B13

 [B15]
   1: len > 0
   T: if [B15.1]
   Preds (1): B16
   Succs (2): B14 B13

 [B16]
   1: [B19.3] ? [B17.1] : ([B18.1])
   2: err_ret->offset = [B16.1]
   3: len = tok->inp - tok->buf
   4: PyObject_Malloc(len + 1)
   5: err_ret->text = (char *)[B16.4]
   6: err_ret->text != ((void *)0)
   T: if [B16.6]
   Preds (2): B17 B18
   Succs (2): B15 B3

 [B17]
   1: col_offset + 1
   Preds (1): B19
   Succs (1): B16

 [B18]
   1: (int)(tok->cur - tok->buf) (CStyleCastExpr, IntegralCast, int)
   Preds (1): B19
   Succs (1): B16

 [B19]
   1: size_t len;
   2: (void)(0) (CStyleCastExpr, ToVoid, void)
   3: col_offset != -1
   T: [B19.3] ? ... : ...
   Preds (1): B20
   Succs (2): B17 B18

 [B20]
   1: err_ret->lineno = tok->lineno
   2: tok->buf != ((void *)0)
   T: if [B20.2]
   Preds (2): B21 B22
   Succs (2): B19 B3

 [B21]
   1: err_ret->error = 11
   Preds (1): B22
   Succs (1): B20

 [B22]
   1: tok->done == 11
   T: if [B22.1]
   Preds (1): B23
   Succs (2): B21 B20

 [B23]
   1: growable_comment_array_deallocate(&type_ignores)
   2: *flags = ps->p_flags
   3: PyParser_Delete(ps)
   4: n == ((void *)0)
   T: if [B23.4]
   Preds (5): B24 B30 B32 B42 B43
   Succs (2): B22 B12

 [B24]
   1: n = ((void *)0)
   Preds (1): B51
   Succs (1): B23

 [B25]
   Preds (2): B28 B29
   Succs (1): B40

 [B26]
   Preds (1): B27
   Succs (1): B29

 [B27]
   1: c = *++cur
   Preds (1): B28
   Succs (1): B26

 [B28]
   1: c != '\n'
   T: while [B29.1] && [B28.1]
   Preds (1): B29
   Succs (2): B27 B25

 [B29]
   1: c (ImplicitCastExpr, IntegralCast, int)
   T: [B29.1] && ...
   Preds (2): B26 B31
   Succs (2): B28 B25

 [B30]
   1: err_ret->error = 27
   2: PyNode_Free(n)
   3: n = ((void *)0)
   T: break;
   Preds (1): B31
   Succs (1): B23

 [B31]
   1: c != '#'
   T: if [B31.1]
   Preds (1): B33
   Succs (2): B30 B29

 [B32]
   T: break;
   Preds (1): B33
   Succs (1): B23

 [B33]
   1: !c
   T: if [B33.1]
   Preds (1): B36
   Succs (2): B32 B31

 [B34]
   Preds (1): B35
   Succs (1): B39

 [B35]
   1: c = *++cur
   Preds (4): B36 B37 B38 B39
   Succs (1): B34

 [B36]
   1: c == '\f'
   T: while [B39.1] || [B38.1] || [B37.1] || [B36.1]
   Preds (1): B37
   Succs (2): B35 B33

 [B37]
   1: c == '\n'
   T: [B39.1] || [B38.1] || [B37.1] || ...
   Preds (1): B38
   Succs (2): B35 B36

 [B38]
   1: c == '\t'
   T: [B39.1] || [B38.1] || ...
   Preds (1): B39
   Succs (2): B35 B37

 [B39]
   1: c == ' '
   T: [B39.1] || ...
   Preds (2): B34 B40
   Succs (2): B35 B38

 [B40]
   T: for (; ; )
   Preds (2): B25 B41
   Succs (2): B39 NULL

 [B41]
   1: char *cur = tok->cur;
   2: char c = *tok->cur;
   Preds (1): B42
   Succs (1): B40

 [B42]
   1: start == 256
   T: if [B43.1] && [B42.1]
   Preds (1): B43
   Succs (2): B41 B23

 [B43]
   1: err_ret->error == 16
   T: [B43.1] && ...
   Preds (3): B46 B48 B50
   Succs (2): B42 B23

 [B44]
   1: i++
   Preds (1): B45
   Succs (1): B48

 [B45]
   1: type_ignores.items[i].comment = ((void *)0)
   Preds (1): B47
   Succs (1): B44

 [B46]
   1: err_ret->error = res
   2: PyNode_Free(n)
   3: n = ((void *)0)
   T: break;
   Preds (1): B47
   Succs (1): B43

 [B47]
   1: PyNode_AddChild(ch, 57, type_ignores.items[i].comment, type_ignores.items[i].lineno, 0, type_ignores.items[i].lineno, 0)
   2: int res = PyNode_AddChild(ch, 57, type_ignores.items[i].comment, type_ignores.items[i].lineno, 0, type_ignores.items[i].lineno, 0);
   3: res != 0
   T: if [B47.3]
   Preds (1): B48
   Succs (2): B46 B45

 [B48]
   1: i < type_ignores.num_items
   T: for (...; [B48.1]; ...)
   Preds (2): B44 B49
   Succs (2): B47 B43

 [B49]
   1: int num;
   2: node *ch;
   3: size_t i;
   4: num = ((n)->n_nchildren)
   5: ch = (&(n)->n_child[num - 1])
   6: (void)(0) (CStyleCastExpr, ToVoid, void)
   7: i = 0
   Preds (1): B50
   Succs (1): B48

 [B50]
   1: n = ps->p_tree
   2: ps->p_tree = ((void *)0)
   3: n->n_type == 257
   T: if [B50.3]
   Preds (1): B51
   Succs (2): B49 B43

 [B51]
   1: err_ret->error == 16
   T: if [B51.1]
   Preds (6): B53 B58 B75 B78 B84 B96
   Succs (2): B50 B24

 [B52]
   Preds (2): B56 B57
   Succs (1): B98

 [B53]
   T: break;
   Preds (2): B54 B55
   Succs (1): B51

 [B54]
   1: PyObject_Free(str)
   2: err_ret->token = type
   Preds (1): B55
   Succs (1): B53

 [B55]
   1: err_ret->error != 16
   T: if [B55.1]
   Preds (1): B56
   Succs (2): B54 B53

 [B56]
   1: PyParser_AddToken(ps, (int)type, str, lineno, col_offset, tok->lineno, end_col_offset, &(err_ret->expected))
   2: (err_ret->error = [B56.1]) != 10
   T: if [B56.2]
   Preds (1): B60
   Succs (2): B55 B52

 [B57]
   T: continue;
   Preds (1): B59
   Succs (1): B52

 [B58]
   1: err_ret->error = 15
   T: break;
   Preds (1): B59
   Succs (1): B51

 [B59]
   1: growable_comment_array_add(&type_ignores, tok->lineno, str)
   2: ![B59.1]
   T: if [B59.2]
   Preds (1): B60
   Succs (2): B58 B57

 [B60]
   1: type == 57
   T: if [B60.1]
   Preds (2): B61 B62
   Succs (2): B59 B56

 [B61]
   1: end_col_offset = -1
   Preds (2): B63 B64
   Succs (1): B60

 [B62]
   1: end_col_offset = (int)(b - tok->line_start)
   Preds (1): B63
   Succs (1): B60

 [B63]
   1: b >= tok->line_start
   T: if [B64.1] && [B63.1]
   Preds (1): B64
   Succs (2): B62 B61

 [B64]
   1: b != ((void *)0)
   T: [B64.1] && ...
   Preds (2): B65 B66
   Succs (2): B63 B61

 [B65]
   1: col_offset = -1
   Preds (2): B67 B68
   Succs (1): B64

 [B66]
   1: col_offset = (int)(a - line_start)
   Preds (1): B67
   Succs (1): B64

 [B67]
   1: a >= line_start
   T: if [B68.3] && [B67.1]
   Preds (1): B68
   Succs (2): B66 B65

 [B68]
   1: [B71.3] ? [B69.1] : [B70.1]
   2: line_start = [B68.1]
   3: a != ((void *)0)
   T: [B68.3] && ...
   Preds (2): B69 B70
   Succs (2): B67 B65

 [B69]
   1: tok->multi_line_start (ImplicitCastExpr, LValueToRValue, const char *)
   Preds (1): B71
   Succs (1): B68

 [B70]
   1: tok->line_start (ImplicitCastExpr, LValueToRValue, const char *)
   Preds (1): B71
   Succs (1): B68

 [B71]
   1: [B74.1] ? [B72.1] : [B73.1]
   2: lineno = [B71.1]
   3: type == 3
   T: [B71.3] ? ... : ...
   Preds (2): B72 B73
   Succs (2): B69 B70

 [B72]
   1: tok->first_lineno (ImplicitCastExpr, LValueToRValue, int)
   Preds (1): B74
   Succs (1): B71

 [B73]
   1: tok->lineno (ImplicitCastExpr, LValueToRValue, int)
   Preds (1): B74
   Succs (1): B71

 [B74]
   1: type == 3
   T: [B74.1] ? ... : ...
   Preds (3): B76 B77 B81
   Succs (2): B72 B73

 [B75]
   1: PyObject_Free(str)
   2: err_ret->expected = 28
   3: err_ret->error = 14
   T: break;
   Preds (1): B76
   Succs (1): B51

 [B76]
   1: strcmp(str, "<>")
   T: if ([B77.1]) && [B76.1]
   Preds (1): B77
   Succs (2): B75 B74

 [B77]
   1: ps->p_flags & 262144
   T: ([B77.1]) && ...
   Preds (2): B79 B80
   Succs (2): B76 B74

 [B78]
   1: PyObject_Free(str)
   2: err_ret->error = 14
   T: break;
   Preds (1): B79
   Succs (1): B51

 [B79]
   1: strcmp(str, "!=")
   T: if [B80.1] && [B79.1]
   Preds (1): B80
   Succs (2): B78 B77

 [B80]
   1: !(ps->p_flags & 262144)
   T: [B80.1] && ...
   Preds (1): B81
   Succs (2): B79 B77

 [B81]
   1: str[len] = '\x00'
   2: type == 28
   T: if [B81.2]
   Preds (2): B82 B83
   Succs (2): B80 B74

 [B82]
   1: strncpy(str, a, len)
   Preds (1): B83
   Succs (1): B81

 [B83]
   1: len > 0
   T: if [B83.1]
   Preds (1): B85
   Succs (2): B82 B81

 [B84]
   1: err_ret->error = 15
   T: break;
   Preds (1): B85
   Succs (1): B51

 [B85]
   1: ([B89.1] && [B88.1]) ? [B86.1] : [B87.1]
   2: len = [B85.1]
   3: PyObject_Malloc(len + 1)
   4: str = (char *)[B85.3]
   5: str == ((void *)0)
   T: if [B85.5]
   Preds (2): B86 B87
   Succs (2): B84 B83

 [B86]
   1: b - a
   Preds (1): B88
   Succs (1): B85

 [B87]
   1: 0 (ImplicitCastExpr, IntegralCast, long)
   Preds (2): B88 B89
   Succs (1): B85

 [B88]
   1: b != ((void *)0)
   T: ([B89.1] && [B88.1]) ? ... : ...
   Preds (1): B89
   Succs (2): B86 B87

 [B89]
   1: a != ((void *)0)
   T: [B89.1] && ...
   Preds (4): B90 B91 B92 B93
   Succs (2): B88 B87

 [B90]
   1: started = 1
   Preds (2): B94 B95
   Succs (1): B89

 [B91]
   1: tok->pendin = -tok->indent
   2: tok->indent = 0
   Preds (1): B92
   Succs (1): B89

 [B92]
   1: !(*flags & 2)
   T: if [B93.3] && [B92.1]
   Preds (1): B93
   Succs (2): B91 B89

 [B93]
   1: type = 4
   2: started = 0
   3: tok->indent (ImplicitCastExpr, LValueToRValue, int)
   T: [B93.3] && ...
   Preds (1): B94
   Succs (2): B92 B89

 [B94]
   1: started (ImplicitCastExpr, LValueToRValue, int)
   T: if [B95.1] && [B94.1]
   Preds (1): B95
   Succs (2): B93 B90

 [B95]
   1: type == 0
   T: [B95.1] && ...
   Preds (1): B97
   Succs (2): B94 B90

 [B96]
   1: err_ret->error = tok->done
   T: break;
   Preds (1): B97
   Succs (1): B51

 [B97]
   1: char *a;
   2: char *b;
   3: int type;
   4: size_t len;
   5: char *str;
   6: col_offset = -1
   7: int lineno;
   8: const char *line_start;
   9: PyTokenizer_Get(tok, &a, &b)
  10: type = [B97.9]
  11: type == 59
   T: if [B97.11]
   Preds (1): B98
   Succs (2): B96 B95

 [B98]
   T: for (; ; )
   Preds (3): B52 B99 B100
   Succs (2): B97 NULL

 [B99]
   1: ps->p_flags |= 4096
   Preds (1): B100
   Succs (1): B98

 [B100]
   1: *flags & 64
   T: if [B100.1]
   Preds (2): B101 B102
   Succs (2): B99 B98

 [B101]
   1: ps->p_flags |= 262144
   Preds (1): B102
   Succs (1): B100

 [B102]
   1: *flags & 32
   T: if [B102.1]
   Preds (1): B104
   Succs (2): B101 B100

 [B103]
   1: err_ret->error = 15
   2: PyTokenizer_Free(tok)
   3: return ((void *)0);
   Preds (1): B104
   Succs (1): B0

 [B104]
   1: PyParser_New(g, start)
   2: (ps = [B104.1]) == ((void *)0)
   T: if [B104.2]
   Preds (1): B106
   Succs (2): B103 B102

 [B105]
   1: err_ret->error = 15
   2: PyTokenizer_Free(tok)
   3: return ((void *)0);
   Preds (1): B106
   Succs (1): B0

 [B106]
   1: parser_state *ps;
   2: node *n;
   3: int started = 0;
   4: int col_offset;
   5: int end_col_offset;
   6: growable_comment_array type_ignores;
   7: growable_comment_array_init(&type_ignores, 10)
   8: ![B106.7]
   T: if [B106.8]
   Preds (1): B107
   Succs (2): B105 B104

 [B0 (EXIT)]
   Preds (3): B1 B103 B105
